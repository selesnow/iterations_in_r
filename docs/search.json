[{"path":"index.html","id":"введение","chapter":"Введение","heading":"Введение","text":"","code":""},{"path":"index.html","id":"о-курсе","chapter":"Введение","heading":"О курсе","text":"Если вы недавно начали изучать язык R, то наверняка неоднократно слышали от более опытных коллег фразу “В R не принято использовать циклы”. Связано это негласное правило с тем, что большинство функций в языке R поддерживают векторизацию, т.е. они уже под капотом имеют встроенный механизм итерирования. Даже если нужная вам функция не поддерживает векторизацию, вы всегда можете использовать функциональный стиль программирования.Циклы, и в целом итерационные конструкции, позволяют избегать излишнего дублирования кода. Основная проблема новичков, которые только начинают учить язык R заключаются в том, что в неумелых руках циклы в R используются не эффективно, и зачастую применяются там, где они вообще не нужны. Цель этого курса научить вас эффективно использовать итерационные конструкции в языке R, и познакомить с функциональным стилем программирования, и многопоточным режимом выполнения скриптов.Этот курс поможет вам погрузиться в тему итерационных конструкций языка R и разобраться во всём их многообразии. Первая лекция даст вам вводную информацию о базовых циклах языка R: , , repeate. Второй урок прольёт свет на обработку ошибок, с которыми могут столкнуться написанные вами циклы. В третьем уроке мы познакомимся с функциональным стилем программирования и семейством функций apply(). Четвёртый урок продолжает тему функционального стиля программирования, в нём мы рассмотрим возможности пакета purrr, который входит в ядро библиотеки tidyverse и предоставляет вам более продвинутые функционалы по сравнению с семейством функций apply(). Следующим шагом мы разберёмся с тем, как перехватывать и обрабатывать ошибки при использовании функционалов. Затем мы узнаем как распараллеливать выполнение итераций ваших циклов и функционалов с помощью многопоточного программирования, изучим конструкцию foreach, пакеты pbapply и furrr. Завершающий урок будет продолжением темы параллельного программирования в R, в котором мы разберём более низкоуровневый интерфейс многопоточности предоставляемый пакетом future.","code":""},{"path":"index.html","id":"для-кого-этот-курс","chapter":"Введение","heading":"Для кого этот курс","text":"Особых требований к уровню подготовки для прохождения данного курса нет, но всё-таки в качестве первого курса для знакомства с языком R я бы его не рекомендовал. Приступать к прохождению курса “Циклы и функционалы в R” я советую тем, кто уже имеет базовые навыки работы в R. Т.е. изначально я рекомендую вам пройти курс “Язык R для пользователей Excel”, и потом приступать к прохождению данного курса.","code":""},{"path":"index.html","id":"рекомендации-по-прохождению-курса","chapter":"Введение","heading":"Рекомендации по прохождению курса","text":"Данный курс состоит из 7 видео лекций общей длительность 2 часа 55 минут, и 7 тестов включающих в себя в общей сложности 30 вопросов. Прохождение тестов не является обязательным, тем не менее я крайне советую пройти тест после просмотра лекции. Тесты помогут акцентировать ваше внимание на наиболее важных моментах урока, и проверить как вы усвоили материал. Фиксируйте баллы, которые вы набираете в ходе выполнения каждого теста, в завершении обучения на курсе, по общей сумме баллов полученных за выполнение всех тестов, вы увидите свою общую оценку за курс.К каждому уроку есть рассмотренный в видео код, это сделано для вашего удобства, скопируйте его и выполняйте по мере просмотра видео лекции. При желании вы можете скачать все примеры кода одним архивом по ссылке.Также в некоторых уроках вы найдёте раздел с рекомендованными материалами. В данный раздел входят ссылки на различные статьи и видео уроки, которые дополняют изложенные в ходе видео материал. Так же рекомендую не игнорировать этот раздел.","code":""},{"path":"index.html","id":"по-поводу-поддержки-обучающихся-на-данном-курса","chapter":"Введение","heading":"По поводу поддержки обучающихся на данном курса","text":"Важно! Поддержки учащихся на этом курсе со стороны автора нет. Я не занимаюсь частными консультациями, тем более не консультирую студентов бесплатных курсов. Поэтому не имеет никакого смысла писать мне в личку или на почту просьбы помочь с прохождением этого, или любого другого моего бесплатного курса. Если вы столкнулись с трудностями при прохождении курса и вам нужна помощь, то все вопросы можно адресовать в следующие telegram чаты:R (язык программирования)Горячая линия RОтдельного чата со студентами непосредственно этого курса не существует, но при желании вы самостоятельно можете его организовать, и я с радостью добавлю на него ссылку.К тому же, если у вас есть вопросы по одной из лекций курса, вы можете задавать его под видео лекции на YouTube, это приветствуется, и на такие комментарии я с радостью отвечу.Буду рад любой конструктивной критике, и предложениям по улучшению курса “Циклы и функционалы в R”, направлять их можно мне на почту selesnow@gmail.com. Если вы хотите выразить благодарность мне за курс, то в конце раздела описано как это можно сделать.","code":""},{"path":"index.html","id":"об-авторе","chapter":"Введение","heading":"Об авторе","text":"Меня зовут Алексей Селезнёв, с 2008 года я являюсь практикующим аналитиком. На данный момент основной моей деятельностью является развитие отдела аналитики в агентстве интернет-маркетинга Netpeak.\nМною были разработаны такие R пакеты как: rgoogleads, ryandexdirect, rfacebookstat, timeperiodsR, rvkstat и некоторые другие. На данный момент написанные мной пакеты только с CRAN были установленны более 150 000 раз.Также я являюсь автором курса “Язык R для интернет-маркетинга” и лектором академии Web Promo Experts.Веду свой авторский Telegram и YouTube канал R4marketing. Буду рад видеть вас в рядах подписчиков.Периодически публикую статью на различных интернет медиа, зачастую это Хабр и Netpeak Journal.Неоднократно выступал на профильных конференциях по аналитике и интернет маркетингу, среди которых Матемаркетинг, GoAnalytics, Analyze, eCommerce, 8P и прочие.Начиная с 2016 года всячески стараюсь популяризировать язык R среди русскоязычных аналитиков и маркетологов. Этот курс также был создан с этой целью.","code":""},{"path":"index.html","id":"каналы-автора","chapter":"Введение","heading":"Каналы автора","text":"Если вы интересуетесь языком R, применяете его в работе, или планируете изучать, то думаю вам будут интересны мои каналы, о которых я писал выше. Буду рад видеть вас среди подписчиков:Telegram канал R4marketingYoutube канал R4marketing","code":""},{"path":"index.html","id":"программа-курса","chapter":"Введение","heading":"Программа курса","text":"Циклы , и repeatОбработка ошибок: конструкции try() и tryCatch()Функции семейства applyИтерирование с помощью функций пакета purrrОбработка ошибок: функции safely(), possibly(), quietly()Введение в многопоточность, пакеты: foreach, doFuture, pbapply, furrrРеализация многопоточности с помощью пакета future","code":""},{"path":"index.html","id":"благодарности-автору","chapter":"Введение","heading":"Благодарности автору","text":"Курс, и все сопутствующие материалы предоставляются бесплатно, но если у вас есть желание отблагодарить автора за этот видео курс вы можете перечислить любую произвольную сумму на этой странице.","code":""},{"path":"циклы-for-while-и-repeat.html","id":"циклы-for-while-и-repeat","chapter":"Урок 1 Циклы for, while и repeat","heading":"Урок 1 Циклы for, while и repeat","text":"","code":""},{"path":"циклы-for-while-и-repeat.html","id":"описание","chapter":"Урок 1 Циклы for, while и repeat","heading":"1.1 Описание","text":"1Цикл — разновидность управляющей конструкции в высокоуровневых языках программирования, предназначенная для организации многократного исполнения набора инструкций.В повседневной жизни мы тоже ежедневно сталкиваемся с циклами. Например, вам необходимо перенести из кухни в комнату 5 больших коробок с посудой, за один раз вы можете поднть только одну коробку. Т.е. вам понадобится пять раз выполнить одно и тоже дейтсвие, это и есть цикл, а перенос одной коробки это одна итерация цикла.Первый урок курса поможет вам разобраться с тем:Что такое циклы;Какие циклы есть в базовом синтаксисе языка R;Как итерироваться циклами по наиболее распространённым структурам данных в R;Как правильно объединять результаты полученные на разных итерациях цикла;Как использовать операторы next и break.Данный урок расчитан на начальный уровень подготовки, и является достаточно базовым.","code":""},{"path":"циклы-for-while-и-repeat.html","id":"видео","chapter":"Урок 1 Циклы for, while и repeat","heading":"1.2 Видео","text":"","code":""},{"path":"циклы-for-while-и-repeat.html","id":"тайм-коды","chapter":"Урок 1 Циклы for, while и repeat","heading":"1.3 Тайм коды","text":"00:00 Введение.\n00:28 Что такое циклы\n00:58 Какие циклы есть в языке R.\n01:44 Синтаксис цикла .\n02:40 Перебираем вектор циклом .\n03:34 Переход на следующую итерацию цикла с помощью оператора next.\n04:50 Перебираем список циклом .\n06:52 Перебираем циклом столбцы и строки таблиц (data.frame).\n09:38 Вложенные циклы .\n10:55 Как правильно объединять в цикле таблицы. Считываем циклом данные из множества csv файлов и объединяем в один data.frame.\n14:11 Синтаксис цикла .\n15:25 Выход из цикла с помощью оператора break.\n17:12 Синтаксис цикла repeat.\n18:30 В чём разница между циклами и repeat в языке R.\n19:47 Почему в R не принято использовать циклы.\n21:17 Заключение.","code":""},{"path":"циклы-for-while-и-repeat.html","id":"код","chapter":"Урок 1 Циклы for, while и repeat","heading":"1.4 Код","text":"","code":"\n# циклы в базовом синтаксисе R\n\n\n# for ---------------------------------------------------------------------\n## выполняется до тех пор,\n## пока в итерируем оъекте не будут перебраны\n## все элементы\n\n## итерирование по вектору\nweek <- c('Sunday', \n          'Monday', \n          'Tuesday', \n          'Wednesday',\n          'Thursday',\n          'Friday',\n          'Saturday')\n\nfor ( day in week ) {\n  \n  print(n)\n  Sys.sleep(0.25)\n  \n}\n\n## итерирование по списку\npersons <- list(\n  list(name = \"Alexey\", age = 36), \n  list(name = \"Justin\", age = 27),\n  list(name = \"Piter\",  age = 22),\n  list(name = \"Sergey\", age = 39))\n\n## оператор next позволяет переходить на следующую итерацию\nfor ( person in persons ) {\n  \n  if ( person$age < 30 ) next\n  \n  print( paste0( person$name, \" is \", person$age, \" years old\") )\n  \n} \n\n## итерирование по таблицам\nfor ( col in mtcars ) {\n  print(mean(col))\n  names(col)\n}\n\n## итерирование по строкам таблицы\nfor ( row in 1:nrow(mtcars) ) {\n  print(mtcars[row, c('cyl', 'gear')])\n}\n\n## вложенные циклы for\nx <- 1:5\ny <- letters[1:5]\n  \nfor ( int in x ) {\n  \n  for ( let in y ) {\n    \n    print(paste0(int, \": \", let))\n    \n  }\n  \n}\n\n## как поступить если мне надо на каждой итерации объединять таблицы\nsetwd('docs')\nfiles <- dir()\nresult <- list()\n\nfor ( file in files ) {\n  \n  temp_df <- read.csv(file)\n\n  result <- append(result, list(temp_df))\n  \n}\n\n# объединяем результаты в одну таблицу\nresult <- do.call('rbind', result)\n\n\n\n# while -------------------------------------------------------------------\n## итерируется до тех пор,\n## пока истинно заданное условие\nx <- 1\n\nwhile ( x < 10 ) {\n  \n  print(x)\n  x <- x + 1\n  \n}\n\n# оператор break\nx <- 1\nwhile ( x < 20 ) {\n  \n  print(x)\n  \n  if ( x / 2 == 5 ) break\n  \n  x <- x + 1\n  \n}\n\n# repeate -----------------------------------------------------------------\n## итерируется до тех пор,\n## пока не встретит break\nx <- 1\n\nrepeat {\n  \n  print(x)\n  \n  if (x / 2 == 5) break\n  \n  x <- x + 1\n}"},{"path":"циклы-for-while-и-repeat.html","id":"презентация","chapter":"Урок 1 Циклы for, while и repeat","heading":"1.5 Презентация","text":"","code":""},{"path":"циклы-for-while-и-repeat.html","id":"тест","chapter":"Урок 1 Циклы for, while и repeat","heading":"1.6 Тест","text":"","code":""},{"path":"обработка-ошибок-конструкции-try-и-trycatch.html","id":"обработка-ошибок-конструкции-try-и-trycatch","chapter":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","heading":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","text":"","code":""},{"path":"обработка-ошибок-конструкции-try-и-trycatch.html","id":"описание-1","chapter":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","heading":"2.1 Описание","text":"На предыдущем уроке мы разобрали всевозможные варианты циклов в языке R, они выполнят сфою функцию, если на одной из итераций не столкнутся с ошибкой, а в противном случае работа цикла не будет завершена и остановится на одной из итераций.В этом уроке мы разберёмся с конструкциями try() и tryCatch() которые позволяют вам перехватывать и обрабатывать ошибки в R.","code":""},{"path":"обработка-ошибок-конструкции-try-и-trycatch.html","id":"видео-1","chapter":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","heading":"2.2 Видео","text":"","code":""},{"path":"обработка-ошибок-конструкции-try-и-trycatch.html","id":"тайм-коды-1","chapter":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","heading":"2.3 Тайм коды","text":"Конструкция try() ( 0:37 )Как использовать try() внутри цикла ( 2:54 )Конструкция tryCatch() ( 7:16 )Обработка ошибок с помощью tryCatch() ( 12:32 )Как использовать tryCatch() внутри цикла ( 13:39 )Блок finally в конструкции tryCatch() (15:27 )Работа с пользовательскими классами исключений ( 19:09 )Векторизируем конструкцию tryCatch() с помощью lapply() ( 24:11 )","code":""},{"path":"обработка-ошибок-конструкции-try-и-trycatch.html","id":"код-1","chapter":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","heading":"2.4 Код","text":"","code":"\n# рабочая директория\nsetwd(r'(C:\\Users\\Alsey\\Documents\\try_catch_lesson)')\n\n# Конструкция try\nres <- try( 10 / 'u' )\n\n# класс объекта\nclass(res)\n\n# сообщение\nattr(res, 'condition')\n\n# пример \nvalues <- list(3, 6, 2, 'x', 7, 3, 't', 9)\n\nfor ( val in values ) {\n  \n  res <- try( val / 10, silent = TRUE )\n  \n  if ( class(res) == 'try-error' ) {\n    \n    print(attr(res, 'condition')) \n    \n  } else {\n    \n    print( paste0( val, \" / 10 = \", res))\n    \n  }\n  \n}\n\n\n# Конструкция tryCatch\n## обработка ошибок\n### функция\ndiv <- function(x, y) {\n  \n  if ( is.na(y) ) {\n    \n    warning(\"Y is NA\")\n    \n  } \n  \n  return( x / y )\n  \n}\n\n### значение\nval <- \"just text\"\n\n### проверка\nresult <- \n  tryCatch( \n    expr = {\n      \n      y <- div(10, val)\n      \n    },\n    error = function(err) {\n      \n      message(err$message)\n      y <- 0\n      \n    },\n    warning = function(war) {\n      \n      message(war$message)\n      y <- 1\n      \n    })\n\n\n### обработка ошибок\nif ( 'error' %in% class(result)  ) {\n  \n  message(\"Catch\")\n  \n}\n\n### в цикле \nvalues <- list(1, 3, NA, 8, \"text\")\n\nfor ( val in values ) {\n  \n  temp <-\n    tryCatch({\n      div(10, val)\n    },\n    error = function(err) {\n      \n      print(err$message)\n      \n    })\n  \n  if ( 'error' %in% class(temp) ) next\n}\n\n\n# блок finnaly\nlibrary(DBI)\nlibrary(RSQLite)\n\n## подключение\ncon <- dbConnect(SQLite(), 'my.db')\n## создаём фрейм\ndf <- data.frame(a = 1:5,\n                 b = letters[1:5])\n\n## попытка записать данные\nout <- \n  tryCatch(\n    {\n      \n      dbWriteTable(con, \n                   'my_data',\n                   df)\n      \n    },\n    \n    error = function(err) {\n      print(err$message)\n      return(err)\n    },\n    \n    finally = {\n      \n      print(\"Закрываю соединение\")\n      dbDisconnect(con)\n    }\n  )\n\n# создаём собственные классы исключений\n## функция дл ягенерации собственных классов исключений\nexception <- function(class, msg)\n  {\n    stop(errorCondition(msg, class = class))\n  }\n\n## функция в которой будем использовать собственные классы исключений\ndivideByX <- function(x){\n  # исключения\n  if (length(x) != 1) {\n    exception(\"NonScalar\", \"x is not length 1\")\n  } else if (is.na(x)) {\n    exception(\"IsNA\", \"x is NA\")\n  } else if (x == 0) {\n    exception(\"DivByZero\", \"divide by zero\")\n  }\n  # результат\n  10 / x\n}\n\n## обработка исключений\nval <- 0\n\ntryCatch(\n  {\n    divideByX(val)\n  }, \n  IsNA = function(x) {\n    print(\"Catch\")\n  },\n  NonScalar = function(x) {\n    print(\"Catch2\")\n  },\n  DivByZero = function(x) {\n    print('Catch3')\n  }\n)\n\n# векторизируем обработку исключений\nlapply(list(NA, 3:5, 0, 4, 7), \n       function(x) tryCatch({\n         \n           divideByX(x)\n         \n       }, \n       IsNA=function(err) {\n            warning(err)  # signal a warning, return NA\n            NA\n       }, \n       NonScalar=function(err) {\n            message(err)     # fail\n       },\n       DivByZero=function(err) {\n            message(err)\n       })\n)"},{"path":"обработка-ошибок-конструкции-try-и-trycatch.html","id":"тест-1","chapter":"Урок 2 Обработка ошибок: конструкции try() и tryCatch()","heading":"2.5 Тест","text":"","code":""},{"path":"функции-семейства-apply.html","id":"функции-семейства-apply","chapter":"Урок 3 Функции семейства apply","heading":"Урок 3 Функции семейства apply","text":"","code":""},{"path":"функции-семейства-apply.html","id":"описание-2","chapter":"Урок 3 Функции семейства apply","heading":"3.1 Описание","text":"На предыдущем уроке мы изучили всевозможные варианты циклов в R, но вам всё время говорят о том, что не надо использовать циклы в R. Возникает вопрос, так что же использовать вместо циклов? На самом деле есть альтернатива в виде функционалов. В этом уроке мы разберёмся с функционалами в базовом синтаксисе R, которые реализованы в семействе функций apply().Функционал - это функция, которая перебирает элементы объекта применяя последовательно к каждому элементу заданную функцию.","code":""},{"path":"функции-семейства-apply.html","id":"видео-2","chapter":"Урок 3 Функции семейства apply","heading":"3.2 Видео","text":"","code":""},{"path":"функции-семейства-apply.html","id":"тайм-коды-2","chapter":"Урок 3 Функции семейства apply","heading":"3.3 Тайм коды","text":"00:00 Вступление.\n00:48 Какие функции входят в семейство apply.\n02:22 Функция apply().\n07:57 Передача дополнительных аргументов в применяемую внутри apply() функцию.\n09:05 Функции lapply(), sapply() и vapply().\n12:09 Как использовать самописную функцию внутри функций семейства apply.\n13:23 Пример чтения данных из множества csv файла функцией lapply().\n15:40 Функция mapply().\n18:00 Заключение.","code":""},{"path":"функции-семейства-apply.html","id":"код-2","chapter":"Урок 3 Функции семейства apply","heading":"3.4 Код","text":"","code":"\n# apply family\n\n# пример с циклом ---------------------------------------------------------\n# строки\nfor ( x in seq_along(1:nrow(mtcars)) ) {\n  cat(rownames(mtcars[x,]), \":\", sum(mtcars[x,]), \"\\n\")\n}\n\n# столбцы\ncol_num <- 1\n\nfor ( x in mtcars ) {\n  cat(names(mtcars)[col_num], \":\", sum(x), \"\\n\")\n  col_num <- col_num + 1\n}\n\n# apply -------------------------------------------------------------------\n# 1 - строки\n# 2 - столюцы\napply(mtcars, 1, sum)\napply(mtcars, 2, sum)\n\nsum(mtcars[3, ])\nsum(mtcars[ ,3])\n# row operation -----------------------------------------------------------\nrowSums(mtcars)\nrowMeans(mtcars)\n# передача дополнительных аргументов --------------------------------------\napply(mtcars, 2, quantile, probs = 0.25)\nquantile(mtcars[, 3], probs = 0.25)\n\n# lapply ------------------------------------------------------------------\nvalues <- list(\n  x = c(4, 6, 1),\n  y = c(5, 10, 1, 23, 4),\n  z = c(2, 5, 6, 7)\n)\n\nlapply(values, sum)\nsapply(values, sum)\nvapply(values, sum, FUN.VALUE = 7)\n\n# lapply с самописной функцией --------------------------------------------\nfl <- function(x) {\n  num_elements <- length(x)\n  return(x[1] + x[num_elements])\n}\n\nlapply(values, fl)\n\n\n# пример чтения файлов ----------------------------------------------------\ndirectory <- 'C:/Users/Alsey/Documents/docs/'\nfiles <- dir(path = directory, pattern = '\\\\.csv$')\nall_data <- list()\n\n# цикл \nfor ( file in files ) {\n  data <- read.csv(paste0(directory, file))\n  all_data <- append(all_data, list(data))\n}\n\ndplyr::bind_rows(all_data)\n\n# lapply\nfile_paths <- paste0(directory, files)\nall_data <- lapply(file_paths, read.csv)\ndplyr::bind_rows(all_data)\n\n\n# mapply ------------------------------------------------------------------\nmapply(rep, 1:4, times=4:1)\nmapply(rep, times = 1:4, x = 4:1)"},{"path":"функции-семейства-apply.html","id":"презентация-1","chapter":"Урок 3 Функции семейства apply","heading":"3.5 Презентация","text":"","code":""},{"path":"функции-семейства-apply.html","id":"тест-2","chapter":"Урок 3 Функции семейства apply","heading":"3.6 Тест","text":"","code":""},{"path":"функции-семейства-apply.html","id":"дополнительные-материалы","chapter":"Урок 3 Функции семейства apply","heading":"3.7 Дополнительные материалы","text":"Статья “Векторизованные вычисления в R с использованием apply-функций” (Сергей Мастицкий).","code":""},{"path":"пакет-purrr.html","id":"пакет-purrr","chapter":"Урок 4 Пакет purrr","heading":"Урок 4 Пакет purrr","text":"","code":""},{"path":"пакет-purrr.html","id":"описание-3","chapter":"Урок 4 Пакет purrr","heading":"4.1 Описание","text":"Рассмотренные в прошлом уроке функции семейства apply действительно полноценно могут заменить цикл , и повысить производительность вашего кода. Но есть и более продвинутые функционалы, которые пердоставляет пакет purrr.В этом уроке вы знаете:Какие преимущества даёт пакет purrr перед функциями apply.Познакомитесь с семействами функций map, map2, pmap, invoke.Узнаете некоторые другие дополнительные функции из пакета purrr.","code":""},{"path":"пакет-purrr.html","id":"видео-3","chapter":"Урок 4 Пакет purrr","heading":"4.2 Видео","text":"","code":""},{"path":"пакет-purrr.html","id":"тайм-коды-3","chapter":"Урок 4 Пакет purrr","heading":"4.3 Тайм коды","text":"00:00 Вступление.\n00:57 Какие преимущества даёт пакет purrr.\n02:15 Какие семейства функций есть в purrr.\n03:29 Семейство функций map.\n04:26 Основные аргументы функций пакета purrr.\n05:20 Работа с функциями семейства map().\n08:23 Пример сравнения map() с циклом .\n08:56 Функции map_dfr(), map_dfc().\n13:01 Итерирование сразу по нескольким объектам, семейства функций map2 и pmap.\n15:01 Синтаксис формул в purrr.\n20:05 Функции семейства walk.\n22:31 Функции keep() и discard().\n26:27 Итерация по функциям с помощью функций семейства invoke.\n29:12 Функции reduce() и accumulate().\n34:23 Заключение.","code":""},{"path":"пакет-purrr.html","id":"код-3","chapter":"Урок 4 Пакет purrr","heading":"4.4 Код","text":"","code":"\n# install.packages('purrr')\nlibrary(purrr)\nlibrary(dplyr)\n\n# функции map_*------------------------------------------------------------\n## Генерируем случайные выборки с нормальным распределением\nv_sizes <- c(5, 12, 20, 30)\nmap(v_sizes, rnorm)\n\n# используем доп аргументы\nrnd_list <- map(v_sizes, runif, min = 10, max = 25)\n# получаем вектора\nmap_dbl(rnd_list, mean)\n# аналог в цикле\nfor ( i in rnd_list ) cat(mean(i), \" \")\n\n# пример с таблицами\nproducts <- tibble(\n  product_id = 1:10,\n  name = c('Notebook',\n           'Smarthphone',\n           'Smart watch',\n           'PC',\n           'Playstation',\n           'TV',\n           'XBox',\n           'Wifi router',\n           'Air conditioning',\n           'Tablet'),\n  price = c(1000, 850, 380, 1500, 1000, 700, 870, 80, 500, 150)\n)\n\nmanagers <- c(\"Svetlana\", \"Andrey\", \"Ivan\")\nclients  <- paste0('client ', 1:30)\n\ncreate_transaction <- function(\n  transaction_id,\n  products_number = 3,\n  product_dict,\n  counts = c(1, 3),\n  dates = c(Sys.Date() - 30, Sys.Date()),\n  managers,\n  clients\n) {\n\n  transaction <- sample_n(product_dict, size = products_number, replace = F) %>%\n                  mutate(date = sample( seq(dates[1], dates[2], by = 'day'), size = 1 ),\n                         manager  = sample(managers, 1),\n                         clients  = sample(clients, 1),\n                         count    = sample(seq(counts[1], counts[2]), products_number, replace = T),\n                         sale_sum = price * count,\n                         transaction_id)\n\n  return(transaction)\n\n}\n\n# генерируем 5 транзакций\nmap_dfr(1:5,\n        create_transaction,\n            products_number = sample(1:10, 1),\n            product_dict = products,\n            counts = c(1, 3),\n            dates = c(Sys.Date() - 30, Sys.Date()),\n            managers = managers,\n            clients = clients,\n        .id = 'transaction_id')\n\n# функции pmap_* ----------------------------------------------------------\n# для итерации по двум объектам можно использовтаь функции map2_*\nx <- list(1, 1, 1)\ny <- list(10, 20, 30)\n\nmap2(x, y, ~ .x + .y)\n\n# если необходимо итерировать более чем по двум объектам используйте pmap_*\nparams <- tibble(\n  transaction_id  = 1:3,\n  products_number = c(4, 2, 6),\n  product_dict    = list(products, products, products),\n  counts          = list(c(1, 3), c(7, 10), c(2, 7)),\n  dates           = list(c(as.Date('2021-11-01'), as.Date('2021-11-04')),\n                         c(as.Date('2021-11-05'), as.Date('2021-11-08')),\n                         c(as.Date('2021-11-09'), as.Date('2021-11-14'))),\n  managers        = list(managers, managers, managers),\n  clients         = list(clients, clients, clients)\n)\n\ntranaction_df <- pmap_df(params, create_transaction)\n\n# функции walk ------------------------------------------------------------\n# генерируем 7 транзакций\ntransactions <- map(1:7,\n                    create_transaction,\n                    products_number = sample(1:10, 1),\n                    product_dict = products,\n                    counts = c(1, 3),\n                    dates = c(Sys.Date() - 30, Sys.Date()),\n                    managers = managers,\n                    clients = clients)\n\nfile_names <- paste0('transaction_', 1:7, \".csv\")\n\nwalk2(\n  .x = transactions,\n  .y = file_names,\n  write.csv\n)\n\n# функции keep и discard --------------------------------------------------\n# смотрим количество товаров в транзакциях\nmap_dbl(transactions, ~ sum(.x$sale_sum))\n# оставить транзакции с суммой более 3000\ntransactions %>%\n  keep(~ sum(.x$sale_sum) >= 3000)\n# исключить транзакции с суммой более 4000\ntransactions %>%\n  discard(~ sum(.x$sale_sum) >= 4000)\n\n# теперь используем в конвейере функции keep и walk\ntransactions %>%\n  keep(~ sum(.x$sale_sum) >= 3000) %>%\n  walk2(\n    .x = .,\n    .y = paste0('transaction_3k_', seq_along(.), \".csv\"),\n    write.csv\n  )\n\n\n# применяем несколько функций к объекту invoke ----------------------------\nfun <- c('mean', 'sum', 'length')\nparams <- list(\n  list(x   = tranaction_df$sale_sum),\n  list(... = tranaction_df$sale_sum),\n  list(x   = tranaction_df$sale_sum)\n)\n\ninvoke_map_dbl(fun, params)\n\n\ndf <- tibble::tibble(\n  f = c(\"runif\", \"rpois\", \"rnorm\"),\n  params = list(\n    list(n = 10),\n    list(n = 5, lambda = 10),\n    list(n = 10, mean = -3, sd = 10)\n  )\n)\n\ndf\n\ninvoke_map(df$f, df$params)\n\n\n# функции reduce и accumulate ---------------------------------------------\n# допустим что у нас каждый менеджер имеет индивидуальный процент от продаж\n# А каждый клиент персональную скидку по договору\nmanagers_dict <- tibble(\n  manager = managers,\n  department = c('Sale', 'Sale', 'Marketing'),\n  salary_percent = c(0.1, 0.12, 0.2)\n)\n\nclients_dict <- tibble(\n  clients = clients,\n  discount = runif(length(clients), min = 0, max = 0.4)\n)\n\ndata_model <- list(tranaction_df, managers_dict, clients_dict)\n\nreduce(transaction_data, left_join) %>%\n  mutate(manager_bonus = sale_sum * salary_percent,\n         total_sum = sale_sum - (sale_sum * discount),\n         cumulate_minuses = accumulate(sale_sum - total_sum + manager_bonus, sum))\n\n# эквивалент на чистом dplyr\ntranaction_df %>%\n  left_join(managers_dict) %>%\n  left_join(clients_dict) %>%\n  mutate(manager_bonus = sale_sum * salary_percent,\n         total_sum = sale_sum - (sale_sum * discount),\n         cumulate_minuses = cumsum(sale_sum - total_sum + manager_bonus))"},{"path":"пакет-purrr.html","id":"презентация-2","chapter":"Урок 4 Пакет purrr","heading":"4.5 Презентация","text":"","code":""},{"path":"пакет-purrr.html","id":"тест-3","chapter":"Урок 4 Пакет purrr","heading":"4.6 Тест","text":"","code":""},{"path":"пакет-purrr.html","id":"дополнительные-материалы-1","chapter":"Урок 4 Пакет purrr","heading":"4.7 Дополнительные материалы","text":"Крайне рекомендую ознакомится с 17 главой книги “Язык R в задачах науки о данных”.","code":""},{"path":"обработка-ошибок-функции-safely-possibly-quietly.html","id":"обработка-ошибок-функции-safely-possibly-quietly","chapter":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","heading":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","text":"","code":""},{"path":"обработка-ошибок-функции-safely-possibly-quietly.html","id":"описание-4","chapter":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","heading":"5.1 Описание","text":"В этом уроке мы продолжаем обсуждать варианты обработки ошибок на языке R. В этот раз мы рассмотрим возможности пакета retry, а так же познакомимся с некоторыми функциями из пакета purrr, которые так же помогут отловить ошибки и предупреждения.","code":""},{"path":"обработка-ошибок-функции-safely-possibly-quietly.html","id":"видео-4","chapter":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","heading":"5.2 Видео","text":"","code":""},{"path":"обработка-ошибок-функции-safely-possibly-quietly.html","id":"тайм-коды-4","chapter":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","heading":"5.3 Тайм коды","text":"Тайм коды:\n1. Обработка ошибок с помощью пакета retry (0:36)\n2. Обработка ошибок с помощью пакета purrr (5:58)\n3. Функция safely() (8:05)\n4. Функция possibly() (9:40)\n5. Функция quietly() (10:53)\n6. Заключение (12:50)","code":""},{"path":"обработка-ошибок-функции-safely-possibly-quietly.html","id":"код-4","chapter":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","heading":"5.4 Код","text":"","code":"\nlibrary(retry)\n\n# тестовая функция \nfun <- function(p = 0) {\n  \n  x <- runif(1)\n  \n  if (runif(1) < 0.9) {\n    \n    print(paste0('X = ', x, ' is Error!'))\n    \n    Sys.sleep(p)\n          \n    stop(\"random error\")\n  }\n  \"Excellent\"\n}\n\n# повторяем функци до тех пор пока она не выполнится\nretry(fun(), when = \"random error\")\n\n# добавим временной интервал между попытками\nretry(fun(), when = \"random error\", interval = 2)\n\n# ограничим количество попыток выполнения функции\nretry(fun(), when = \"random error\", max_tries = 3)\n\n# ограничим время выполнения функции\nretry(fun(4), when = \"random error\", timeout = 2)\n\n# проверяем результат выполнения выражения\n# val это выражение которое мы проверяем\n# cnd результат вычисления val\nretry(fun(), until = function(val, cnd) val == \"Excellent\")\n\nlibrary(purrr)\n\n# тестовая функция\ndiv <- function(x, y) {\n  \n  if ( is.na(x) ) warning(\"X is NA\")\n  return(x / y)\n\n}\n\n# пробуем обработку через lapply\nval <- list(1, 6, 3, NA, 'k', 3)\n# тест\nlapply(val, div, y = 2)\n\n# ######### #\n# safely    #\n# ######### #\n# разделит успешные результаты и ошибки\nres <- lapply(val, safely(div), y = 2)\n\n# разбить ошибкии корректные результаты по векторам\nres <- res %>% transpose()\n\nres$result # успешные результаты\nres$error  # ошибки\n\n# ######### #\n# possibly  #\n# ######### #\n# данная функция заменит ошибки заданным значением\nres <- lapply(val, possibly(div, 0), y = 2) \n\n# ######### #\n# quietly   #\n# ######### #\n# перехватыет выводимые результаты, сообщения и предупреждения\nval <- list(1, 6, 3, NA, 3)\nres <- map(val, quietly(div), y = 2) %>% str"},{"path":"обработка-ошибок-функции-safely-possibly-quietly.html","id":"тест-4","chapter":"Урок 5 Обработка ошибок: функции safely(), possibly(), quietly()","heading":"5.5 Тест","text":"","code":""},{"path":"многопоточность-в-r.html","id":"многопоточность-в-r","chapter":"Урок 6 Многопоточность в R","heading":"Урок 6 Многопоточность в R","text":"","code":""},{"path":"многопоточность-в-r.html","id":"описание-5","chapter":"Урок 6 Многопоточность в R","heading":"6.1 Описание","text":"Давайте представим ситуацию, что вам необходимо доствить 8 адресатам посылки. Если вы будете доставлять их одним курьером, то ему придётся по очереди посетить все 8 адресов, собрать подписи в качестве подтверждения о получении посылки, и принести вам подписанные документы. но если у вас в распоряжении будет 4 курьера, то вы сможете распределить каждому курьеру всего по 2 адреса, и процесс доставки займёт в 4 раза меньше времени.Ок, а при чём тут вообще курьеры спросите вы. Во всех предыдущих уроках мы выполняли итерирование по элементов объектов в последовательном режиме, т.е. использовали одного курьера. Это преемлемый способ итерирования, но не самый эффективный. В этом уроке мы с вами разберёмся с тем, как задействовать сразу 4ёх курьеров, т.е. выполнять итерации в параллеьном, многопоточном режиме.Так же мы можем сделать этот процесс ещё более эффективным, если будем не рандомно раздавать курьерам адресатов, а например распредим каждому курьеру по одному району, это балансировка нагрузки, её мы тоже затронем в этом уроке.","code":""},{"path":"многопоточность-в-r.html","id":"видео-5","chapter":"Урок 6 Многопоточность в R","heading":"6.2 Видео","text":"","code":""},{"path":"многопоточность-в-r.html","id":"тайм-коды-5","chapter":"Урок 6 Многопоточность в R","heading":"6.3 Тайм коды","text":"00:00 Вступление.\n00:51 Что такое многопоточность.\n02:20 Какие пакеты мы будем использовать в ходе урока.\n03:25 Используем foreach в последовательном режиме.\n07:42 Аргументы конструкции foreach.\n10:05 Управление объединением результатов итераций цикла foreach.\n11:05 Выполнение foreach в многопоточном режиме.\n12:41 Схема реализации многопоточности.\n13:52 Возвращение к последовательному выполнению и ID процесса.\n14:56 Бекенды к foreach.\n15:38 Оператор %dorng%.\n18:10 Параллельная реализация функций семейства apply.\n20:52 Список функций пакетов parallel и pbapply.\n21:54 Пакет furrr.\n23:10 Соответствие функций пакета purrr и furrr.\n23:50 Заключение.","code":""},{"path":"многопоточность-в-r.html","id":"код-5","chapter":"Урок 6 Многопоточность в R","heading":"6.4 Код","text":"","code":"\n# многопоточные циклы -----------------------------------------------------\n# install.packages(\"doSNOW\")\n# library(doSNOW)\n# library(doParallel)\nlibrary(doFuture)\n\n# функция длительного выполнения\npause <- function(min = 1, max = 3) {\n  ptime <- runif(1, min, max)\n\n  Sys.sleep(ptime)\n\n  out <- list(\n    pid = Sys.getpid(),\n    pause_sec = ptime\n  )\n}\n\ntest <- pause()\n\n# используем foreach \n# итерируемся сразу по двум объектам\nsystem.time (\n  {test2 <- foreach(min = 1:3, max = 2:4) %do% pause(min, max)}\n)\n\n# сумма длительностей пауз\nsum(sapply(test2, '[[', i = 'pause_sec'))\n\n# меняем функцию собирающую результаты каждой итерации\ntest3 <- foreach(min = 1:3, max = 2:4, .combine = dplyr::bind_rows) %do% pause(min, max)\n\n# параллельный режим выполнения\n# создаём кластер из четырёх ядер\n#cl <- makeCluster(4)\n#registerDoSNOW(cl)\n\noptions(future.rng.onMisuse = \"ignore\")\nregisterDoFuture()\nplan('multisession', workers = 3)\n\n# выполняем тот же код но в параллельном режиме\nsystem.time (\n  {\n    par_test1 <- \n      foreach(min = 1:3, max = 2:4, .combine = dplyr::bind_rows) %dopar% {\n      pause(min, max)\n    }\n  }\n)\n\n# останавливаем кластер\nplan('sequential')\n\npar_test1\n\n\n# многопоточный вариант функций apply -------------------------------------\n\nlibrary(pbapply)\nlibrary(parallel)\n\n# создаём кластер из четырёх ядер\ncl <- makeCluster(3)\n\n# пример с pbapply\npar_test2 <- pblapply(rep(1, 3), FUN = pause, max = 3, cl = cl)\n# пример с parallel\npar_test3 <- parLapply(rep(1, 3), fun = pause, max = 3, cl = cl)\n\n# останавливаем кластер\nstopCluster(cl)\n\n# многопоточный purrr -----------------------------------------------------\nlibrary(furrr)\n\nplan('multisession', workers = 3)\n\npar_test4 <- future_map2(1:3, 2:4, pause)\n\n# останавливаем кластер\nplan('sequential')"},{"path":"многопоточность-в-r.html","id":"презентация-3","chapter":"Урок 6 Многопоточность в R","heading":"6.5 Презентация","text":"","code":""},{"path":"многопоточность-в-r.html","id":"тест-5","chapter":"Урок 6 Многопоточность в R","heading":"6.6 Тест","text":"","code":""},{"path":"многопоточность-в-r.html","id":"дополнительные-материалы-2","chapter":"Урок 6 Многопоточность в R","heading":"6.7 Дополнительные материалы","text":"Статья “Как ускорить работу с API на языке R с помощью параллельных вычислений, на примере API Яндекс.Директ (Часть 1)”","code":""},{"path":"пакет-future.html","id":"пакет-future","chapter":"Урок 7 Пакет future","heading":"Урок 7 Пакет future","text":"","code":""},{"path":"пакет-future.html","id":"описание-6","chapter":"Урок 7 Пакет future","heading":"7.1 Описание","text":"В заключительном уроке этого курса мы познакомимся с наиболее продвинутым интерйесом параллельного программирования на языке R, который предоставляет пакет future.","code":""},{"path":"пакет-future.html","id":"видео-6","chapter":"Урок 7 Пакет future","heading":"7.2 Видео","text":"","code":""},{"path":"пакет-future.html","id":"тайм-коды-6","chapter":"Урок 7 Пакет future","heading":"7.3 Тайм коды","text":"00:00 Вступление.\n01:15 Явное и неявное объявление фьючерсов.\n04:33 Аргументы функции ё.\n05:40 Локальное окружение фьючерса.\n06:42 Стратегии выполнения вычислений в пакете future.\n08:20 Как менять стратегию выполнения кода с помощью future.\n10:42 Настройка плана cluster.\n12:09 Вложенные друг в друга фьючерсы.\n18:00 Отладка ошибок в фьючерсах.\n19:03 Многопоточное итерирование с помощью future.\n21:58 Пример использования future в многопоточном режиме.\n26:07 Опции и переменные среды пакета future.\n28:00 Другие пакеты входящие в библиотеку futureverse.\n29:10 Заключение.","code":""},{"path":"пакет-future.html","id":"код-6","chapter":"Урок 7 Пакет future","heading":"7.4 Код","text":"","code":"\nlibrary(future)\nlibrary(dplyr)\n\n# явное и неявное объявление фьючерсов ------------------------------------\n# обычное выражение\nv <- {\n  cat(\"Hello world!\\n\")\n  3.14\n}\n\n# неявное объявление фьчерса\nv %<-% {\n  cat(\"Hello world!\\n\")\n  3.14\n}\n\n# явное объявления фьючерса\nf <- future({\n  cat(\"Hello world!\\n\")\n  3.14\n})\nv <- value(f)\nresolved(f)\n# фьючерс выполняет все вычисления в собственном окружении -----------------\na <- 1\n\nx %<-% {\n  a <- 2\n  2 * a\n}\n\nx\n\na\n\n# изменяем план выполнения фьючерса ---------------------------------------\n## последовательное выполнение\nplan(sequential)\npid <- Sys.getpid()\npid\n\na %<-% {\n  pid <- Sys.getpid()\n  cat(\"Future 'a' ...\\n\")\n  3.14\n  }\nb %<-% {\n  cat(\"Future 'b' ...\\n\")\n  Sys.getpid()\n  }\nc %<-% {\n  cat(\"Future 'c' ...\\n\")\n  2 * a\n  }\n\nb\nc\na\npid\n\n## ассинхронное выполнение\n### режим параллельно запущенных сеансов R\nplan(multisession)\npid <- Sys.getpid()\npid\n\na %<-% {\n  pid <- Sys.getpid()\n  cat(\"Future 'a' ...\\n\")\n  cat('pid: ', pid)\n  3.14\n  }\nb %<-% {\n  cat(\"Future 'b' ...\\n\")\n  Sys.getpid()\n  }\nc %<-% {\n  cat(\"Future 'c' ...\\n\")\n  2 * a\n}\n\nb\n\nc\n\na\n\npid\n\nplan(sequential)\n\n# просмотрт доступного количества потоков\navailableCores()\n\n### кластерное развёртывание\nlibrary(parallel)\ncl <- parallel::makeCluster(3)\nplan(cluster, workers = cl)\n\npid <- Sys.getpid()\npid\n\na %<-% {\n  pid <- Sys.getpid()\n  cat(\"Future 'a' ...\\n\")\n  cat('pid: ', pid)\n  3.14\n}\nb %<-% {\n  cat(\"Future 'b' ...\\n\")\n  Sys.getpid()\n}\nc %<-% {\n  cat(\"Future 'c' ...\\n\")\n  2 * a\n}\n\nb\n\nc\n\na\n\npid\n\nparallel::stopCluster(cl)\n\n\n# вложенные фьчерсы -------------------------------------------------------\nplan(list(multisession, sequential))\n# plan(list(sequential, multisession))\n\n# указываем количество ядер для каждого процесса\n# plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 2)))\npid <- Sys.getpid()\na %<-% {\n  cat(\"Future 'a' ...\\n\")\n  Sys.getpid()\n  }\nb %<-% {\n  cat(\"Future 'b' ...\\n\")\n  b1 %<-% {\n    cat(\"Future 'b1' ...\\n\")\n    Sys.getpid()\n    }\n  b2 %<-% {\n    cat(\"Future 'b2' ...\\n\")\n    Sys.getpid()\n    }\n  c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2)\n  }\n\npid\n\na\nb\n\nplan(sequential)\n\n\n# обработка ошибок в фьючерсах --------------------------------------------\nplan(sequential)\nb <- \"hello\"\na %<-% {\n  cat(\"Future 'a' ...\\n\")\n  log(b)\n  } %lazy% TRUE\n\na\n\n# смотрим где именно была ошибка\nbacktrace(a)\n\n# используем итерирование в параллельныъ процессах ------------------------\n# тестовая функция\nmanual_pause <- function(x) {\n  Sys.sleep(x)\n  out <- list(pid = Sys.getpid(), pause = x)\n  return(out)\n} \n\n# паузы\npauses <- c(0.5, 2, 3, 2.5) \n\n# тест\nmanual_pause(2)\n\n# активируем параллельные вычисления\nplan(\"multisession\", workers = 4)\n# итерируемся\nfuts <- lapply(pauses, function(i) future({ manual_pause(i) }))\n# проверяем статус выполнения фьючерсов\nsapply(futs, resolved) \n# собираем результаты\nres <- lapply(futs, value)    \n\ndplyr::bind_rows(res)\n\n\n# используем future совместно с promises ----------------------------------\nlibrary(cli)\noptions(cli.progress_show_after = 0, \n        cli.spinner = \"dots\")\n\n# паузы\npauses.1 <- sample(1:5, 4, replace = T)\npauses.2 <- sample(2:3, 4, replace = T)\npauses.3 <- sample(3:6, 4, replace = T)\n\n# первое длительное вычисление\nplan(list(\n  tweak(multisession, workers = 3), \n  tweak(multisession, workers = 4)\n  )\n)\n\nval1 <- future(\n  {\n    futs <- lapply(pauses.1, function(i) future({ manual_pause(i) }))\n    res  <- lapply(futs, value) \n    res  <- dplyr::bind_rows(res)\n  }\n) \n\nval2 <- future(\n  {\n    futs <- lapply(pauses.2, function(i) future({ manual_pause(i) }))\n    res  <- lapply(futs, value) \n    res  <- dplyr::bind_rows(res)\n  }\n) \n\nval3 <- future(\n  {\n    futs <- lapply(pauses.3, function(i) future({ manual_pause(i) }))\n    res  <- lapply(futs, value) \n    res  <- dplyr::bind_rows(res)\n  }\n) \n\n# ждём выполнения всех фьючерсов\ncli_progress_bar(\"Waiting\")\nwhile ( ! (resolved(val1) | resolved(val2) | resolved(val3)) ) {\n  cli_progress_update()\n}\n\ncli_progress_update(force = TRUE)\n\n# result table\nlapply(list(val1, val2, val3), value) %>% \n  bind_rows() %>%  \n  mutate(main_pid = Sys.getpid()) %>% \n  print() %>%\n  pull(pause) %>% \n  sum()  %>% \n  cat(\"\\n\", \"Sum of all pauses: \", ., \"\\n\")\n\nplan(sequential)"},{"path":"пакет-future.html","id":"презентация-4","chapter":"Урок 7 Пакет future","heading":"7.5 Презентация","text":"","code":""},{"path":"пакет-future.html","id":"тест-6","chapter":"Урок 7 Пакет future","heading":"7.6 Тест","text":"","code":""},{"path":"пакет-future.html","id":"дополнительные-материалы-3","chapter":"Урок 7 Пакет future","heading":"7.7 Дополнительные материалы","text":"Статья “Как ускорить работу с API на языке R с помощью параллельных вычислений, на примере API Яндекс.Директ (Часть 2)”.","code":""},{"path":"заключение.html","id":"заключение","chapter":"Заключение","heading":"Заключение","text":"Поздравляю вас с завершением мини курса “Циклы и функционалы в языке R”!","code":""},{"path":"заключение.html","id":"общая-оценка-за-курс","chapter":"Заключение","heading":"Общая оценка за курс","text":"Максимальное количество баллов, которое можно было набрать при прохождении тестов 42. В связи с чем можете самостоятельно оценить насколько хорошо вы усвоили материал:менее 24 баллов: К сожалению этот курс вам ничего не дал, рекомендую начинать с курса “Язык R для пользователей Excel”, и после его прохождения повторить попытку изучения курса “Циклы и функционалы в языке R”. Общая оценка по курсу Оценка 2.24 - 29 балла: Скорее всего вам следуюет пересмотреть лекции, т.к. вы не усвоили практически половину изложенного материала. Общая оценка по курсу Оценка 3.30 - 34 баллов: Вы усвоили большую часть материала, тем не менее остались важные моменты, которые пока, что судя по всему вам не понятны. Пересмотрите урок, по которому вы получили низкую оценку. Общая оценка по курсу Оценка 4.35 - 42 балла: Поздравляю, вы успешно ответили на подавляющее большинство вопросов в тестах, те вопросы на которые вы ответили неправильно возможно были непонятно сформулированы. Общая оценка по курсу Оценка 5.Не зависимо от колличества набранных баллов я рекомендую вам не останавливаться на достингнутом, и продолжать прокачивать навыки работы в R.","code":""},{"path":"заключение.html","id":"поблагодарить-автора-за-курс","chapter":"Заключение","heading":"Поблагодарить автора за курс","text":"Если этот курс был вам полезен, и у вас есть желание выразить за него благодарность, вы можете перевести любую сумму на этой странице, либо использовать кнопку:\nБуду рад видеть вас в числе подписчиков моего канала в Telegram и на YouTube. В канале вы найдёте очень много полезной информации по R.Удачи вам!","code":""},{"path":"заключение.html","id":"контакты-автора","chapter":"Заключение","heading":"Контакты автора","text":"email: selesnow@gmail.comtelegram канал: R4marketingyoutube канал: R4marketingtelegram: AlexeySeleznevfacebook: selesnowgithub: selesnowlinkedin: selesnowблог: alexeyseleznev.wordpress.com","code":""}]
